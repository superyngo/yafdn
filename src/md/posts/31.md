---
number: 31
title: 徹底搞懂javascript原型鍊
createdAt: 2023-09-10T14:43:46Z
publishedAt: 2023-09-10T14:43:46Z
lastEditedAt: 2023-09-11T08:44:28Z
url: https://github.com/superyngo/hakuba_template/discussions/31
category:
  name: posts
labels:
  nodes:
    - name: javcascript
      color: 509AB1
---
Javascript的物件導向是基於原型鍊實現，這個原型鍊基本上由：  
1. 原型function的prototype property
2. 原型function作為prototype內的constructor  
3. object的__proto__ property  
構成，搞懂這3者的意義和交互關係就能徹底搞懂原型鍊。  

# function.prototype.constructor===function
在有class以前，我們在原型function內使用this定義property以打造object的內容，並用new產出帶有這些property的object。  
通常會稱這個原型function是個constructor，這個稱呼雖然沒有錯，但其實，所謂constructor是任何function都會有的東西。   
當定義一個fcuntion時，會呼叫Function這個constructor，在其內長出一個特別的property：prototype。  
prototype本身又是個object，並且包含constructor method，而constructor method其實就是function本身，形成cyclic object的結構。  
也就是`function.prototype.constructor===function`  

## object的種子：constructor
constructor的功能，就像是顆種子一樣，用this.property提供object建立屬於自己的基本property，例如：  
```js
function Dog (name){
  this.name=name
}
const snoopy= new Dog("Snoopy")
snoopy.name //"Snoopy"
```
當我們用new去執行原型function時，就是先創造一個空的object，把原型function種在這個空object內，讓它發芽，藉此把原型function內用this定義的property在object內長出來。至於原型function是怎麼以constructor的形式種進空object內的，我們稍後解釋。  

## object的根：prototype
object不只可以從prorotype獲得種子，還可以使用prototype的所有屬性，這就是為何原型function要多用一層prototype把自己包起來，因為透過這多一層包裝，就可以在constructor外增加不同的methds讓後代子孫使用，也因此在class出現前定義method要定義在原型function的prototype上。  
```js
function Dog(name){
  this.name=name
}
Dog.prototype.bark=function(){
  console.log(this.name + "bark!")
}
const snoopy = new Dog("Snoopy")
snoopy.bark() // "Snoopy bark!"
```
## object的莖：__proto__
說完prototype及constructor，有沒有發現，這兩樣東西雖然是object的根和種子，卻都長在原型function身上，那他們到底是怎麼和object連上去的？  
沒錯，就是透過__proto__這個getter/setter，設定object的原型到指定的prototype上。有趣的是，__proto__本身就是Object.prototype提供的getter/setter，作為objects之母的Object.prototype，因為有提供__proto__這個setter/getter，才讓所有後代子孫最終都能接回其身上。  
那麼作為objects之母的Object.prototype，本身既然也是個object，若令其呼叫__proto__這個方法會得到誰呢？答案是null，而且嘗試用Object.prototype.__proto__設定任何prototype都會出錯。  

# 手動模擬prototype原型鍊

先複習一下，__proto__是所有object都能呼叫使用的getter/setter，定義在objects之母：Object.prototype身上；Object.prototype則來自Object作為一個function，必定擁有的property，這個property既把Object作為原型function包成constructor這個method，其上所定義的各種methods也都可被後代呼叫。  
當用new+原型function去創建一個object時，首先會先創造一個空object，接著用object.__proto__設定其原型鍊至原型function.prototype，最後執行object.constructor()(也就是在空object身上執行原型function)將原型function內用this定義的property長出來。  
可見，prototype其實就只是個包含了constructor在內各種method或setter/getter的object，只是長在function裡面而以。以下就用code模擬其功能：  
```js
//先做一個fake prototype
const fakePrototype={
  constructor(name){
     this.name=name
  },
  sayMyName(){console.log(this.name)}
}
//做一個空object並將其原型設定到fake prototype
const obj={}
obj.__proto__=fakePrototype
console.log(obj) // {} 此時obj還是空的
obj.constructor("John")
console.log(obj) // { name: "John" } 透過this.name長出屬於自己的name property
obj.sayMyName() // John   這邊呼叫了原型方法
```
## 改用Object.create試看看
我們也可以用Object.create模擬：
```js
//先做一個fake prototype
const fakePrototype={
  constructor(name){
     this.name=name
  },
  sayMyName(){console.log(this.name)}
}
//直接用fakePrototype生出一個物件
const obj=Object.create(fakePrototype)
console.log(obj) // {} 此時obj還是空的
obj.constructor("John")
console.log(obj) // { name: "John" } 透過this.name長出屬於自己的name property
obj.sayMyName() // John  這邊呼叫了原型方法
```
從上面的模擬也可以發現，Object.create實際上只做了2件事：創造空object、把空object的__proto__設定到目標的prototype上。也因此object剛生出來時依然是空的，只是可以取用其prototype上的所有property而已。那如果想像用new+原型function快速在這個空object內長出property要怎麼做呢？很簡單，就再執行一次object.constructor()就可以：
```js
//接續上面的模擬，但改將obj當作prototype
const obj2=Object.create(obj)
console.log(obj2) // {} 此時obj2還是空的
obj2.sayMyName() // John   雖然是空object，但可以讀取到obj的property name和fakePrototype的原型method：sayMyName
obj2.constructor("Mary")
console.log(obj2) // { name: "Mary" } 透過this.name長出屬於自己的name property，因此不會再去讀取obj的name了
```
# prototype method/property vs this.methods/property within constructor
經過以上敘述，我們已經了解在定義原型時，定義在prototype上的methods及property都可以被後代子孫取用，那如果改在constructor內用this定義呢？兩者有什麼差別呢？
```js
//這邊直接用class比較容易呈現
class Dog{
  constructor(name){
    this.name=name
  };
  bark(){console.log(this.name + " bark!")}
}

class Dog{
  constructor(name){
    this.name=name;
    this.bark(){console.log(this.name + " bark!")}
  };
}
```
最主要的差別在於，定義在prototype上的methods屬於原型方法，後代子孫在取用時都屬於同一instance，而定義在constructor內的methods則會各自長在所有後代子孫內，會占用更多記憶體資源。

講到這邊，相信應該可基本上釐清javascript的原型鍊是如何運作，那後面就可以探討factory function和class/原型function的差別了。先洩漏關鍵字：closure。

參考資料：
[Day13 前端蛇行撞牆記 - Constructor function 建構式函式](https://ithelp.ithome.com.tw/articles/10300139)
